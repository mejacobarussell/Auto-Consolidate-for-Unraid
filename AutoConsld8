#!/bin/bash
# Autoconsld8 - Fully Automated or Interactive Consolidation for unRAID

# --- Configuration & Constants ---
BASE_SHARE="/mnt/user/TVSHOWS"
# 200 GB minimum free space safety margin (in 1K blocks, as df/du output)
MIN_FREE_SPACE_KB=209715200 
# ---------------------------------

usage(){
cat << EOF

usage: consld8-auto [options:-h|-t|-f|-v|-a]

This script has two modes:
1. Interactive Mode (Default): Prompts for folder and disk selection.
2. Automatic Mode (-a): Scans all folders and generates an optimized move plan.

options:
  -h    Display this usage information.
  -t    Perform a test run (Dry Run). No files will be moved.
  -f    Override test mode and force valid moves to be performed.
  -v    Print more information (recommended for auto mode).
  -a    *** Run in FULL AUTOMATIC PLANNING MODE ***

EOF
}

# Set shell options
shopt -s nullglob  # remove words with no matching filenames
[ ${DEBUG:=0} -gt 0 ] && set -x -v

# --- Variables ---
verbose=1
dry_run=true      # Default to safety (Test mode)
auto_mode=false   # Default to interactive mode

# --- Argument Parsing ---
while getopts "htfva" opt; do
  case "$opt" in
    h)
      usage
      exit 0
      ;;
    t) # Specify test mode
      dry_run=true
      ;;
    f) # Override test mode and force action
      dry_run=false
      ;;
    v)
      verbose=$((verbose + 1))
      ;;
    a) # Activate Automatic Mode
      auto_mode=true
      ;;
    *)
      echo "Unknown option (ignored): -$OPTARG" >&2
      ;;
  esac
done
shift $((OPTIND-1))

# --- Core Logic for Automated Planning ---

auto_plan_and_execute() {
    echo "--------------------------------------------------------"
    echo "  Starting FULL AUTOMATED CONSOLIDATION PLANNER         "
    echo "--------------------------------------------------------"
    echo "Base Share: $BASE_SHARE"
    echo "Safety Margin: $(numfmt --to=iec --from-unit=1K $MIN_FREE_SPACE_KB) minimum free space"
    
    if [ "$dry_run" = true ]; then
        echo ">> MODE: DRY RUN (Planning Only, no files will move)"
    else
        echo ">> MODE: FORCE (Files WILL be moved)"
    fi
    echo ""

    # Declare associative arrays to track disk state during planning
    declare -A DISK_FREE
    declare -A DISK_SHARE_USAGE
    
    # 1. Initialize Disk Free Space and Share Usage for all disks
    echo "Scanning initial disk state..."
    for d_path in /mnt/{disk[1-9]{,[0-9]},cache}; do
        disk_name="${d_path#/mnt/}"
        
        # CRITICAL FIX: Robustly get the Available blocks using df -P
        current_free=$(df -P "$d_path" | tail -1 | awk '{ print $4 }')
        
        # Check if current_free is empty or non-numeric (setting to 0 if invalid)
        if ! [[ "$current_free" =~ ^[0-9]+$ ]]; then
            current_free=0
            echo "  WARNING: Failed to read free space for $disk_name. Assuming 0KB free."
        fi
        
        DISK_FREE["$disk_name"]="$current_free"

        # Calculate share usage (DUSAGE) for the entire BASE_SHARE on this disk
        if [ -d "$d_path/$BASE_SHARE" ]; then
            current_share_usage=$(du -s "$d_path/$BASE_SHARE" | cut -f 1)
        else
            current_share_usage=0
        fi
        DISK_SHARE_USAGE["$disk_name"]="$current_share_usage"
        
        [ $verbose -gt 1 ] && echo "  $disk_name: Free=$(numfmt --to=iec --from-unit=1K ${DISK_FREE[$disk_name]}), ShareUsed=$(numfmt --to=iec --from-unit=1K ${DISK_SHARE_USAGE[$disk_name]})"
    done
    
    # Array to hold the final execution plan
    PLAN_ARRAY=()
    
    # 2. Iterate through all subdirectories and create the plan
    echo ""
    echo "Generating Consolidation Plan..."
    
    # Loop through subdirectories of the base share (e.g., TVSHOWS/Show1, TVSHOWS/Show2)
    while IFS= read -r full_src_path; do
        
        share_component="${full_src_path#/mnt/user/}" # TVSHOWS/ShowName
        if [ -z "$share_component" ]; then continue; fi 
        
        folder_name="${full_src_path##*/}" # Just the folder name (e.g., ShowName)
        folder_size=$(du -s "$full_src_path" | cut -f 1)
        
        if [ "$folder_size" -lt 10 ]; then continue; fi

        # --- NEW LOGIC: Check if folder is already consolidated ---
        CONSOLIDATED_DISK_COUNT=0
        for d_path in /mnt/{disk[1-9]{,[0-9]},cache}; do
            # Check if the folder path exists on this physical disk
            if [ -d "$d_path/$share_component" ]; then
                
                # *** FIX FOR BROKEN PIPE ERROR ***
                # Check if it contains files by capturing the output of find | head
                if [ -n "$(find "$d_path/$share_component" -mindepth 1 -type f 2>/dev/null | head -n 1)" ]; then
                     CONSOLIDATED_DISK_COUNT=$((CONSOLIDATED_DISK_COUNT + 1))
                fi
                # --- END FIX ---
            fi
        done

        if [ "$CONSOLIDATED_DISK_COUNT" -le 1 ]; then
            echo "  [SKIP]: '${share_component}' (Size: $(numfmt --to=iec --from-unit=1K $folder_size)) - Already consolidated to $CONSOLIDATED_DISK_COUNT disk(s). Skipping calculation."
            continue
        fi
        # --- END NEW LOGIC ---

        # Tracking variables for the new priority logic
        MAX_FILE_COUNT=-1
        MAX_FREE_SPACE=-1
        BEST_DEST_DISK=""
        
        # Get total usage of the entire share across all disks
        TOTAL_SHARE_SIZE=0
        for disk_name in "${!DISK_SHARE_USAGE[@]}"; do
             TOTAL_SHARE_SIZE=$((TOTAL_SHARE_SIZE + DISK_SHARE_USAGE[$disk_name]))
        done

        # 2a. Find the best destination disk using new File Count > Free Space priority
        for d_path in /mnt/{disk[1-9]{,[0-9]},cache}; do
            disk_name="${d_path#/mnt/}"
            
            # --- 1. Calculate Required Space (Cost) ---
            # Current usage of this folder on this specific disk
            if [ -d "$d_path/$share_component" ]; then
                current_folder_on_disk_size=$(du -s "$d_path/$share_component" | cut -f 1)
            else
                current_folder_on_disk_size=0
            fi

            # ODUSAGE: Total size to move *to* this disk (Total Share Size - current usage on this disk)
            ODUSAGE=$((TOTAL_SHARE_SIZE - DISK_SHARE_USAGE[$disk_name]))

            # REQUIRED_SPACE: Net space required on this disk
            REQUIRED_SPACE=$((ODUSAGE - current_folder_on_disk_size))
            if [ "$REQUIRED_SPACE" -lt 0 ]; then REQUIRED_SPACE=0; fi
            
            # --- 2. Safety Check (Must pass this to be considered) ---
            DFREE="${DISK_FREE[$disk_name]}"
            if [ "$((DFREE - REQUIRED_SPACE))" -lt "$MIN_FREE_SPACE_KB" ]; then
                [ $verbose -gt 2 ] && echo "    $disk_name FAILED safety check. Free: $(numfmt --to=iec --from-unit=1K $DFREE) vs Needed: $(numfmt --to=iec --from-unit=1K $REQUIRED_SPACE). Skipping."
                continue # Skip to next disk
            fi
            
            # --- 3. Optimization Metrics (Only for valid candidates) ---
            CURRENT_FREE_SPACE="$DFREE"
            CURRENT_FOLDER_PATH="$d_path/$share_component"

            # Count files for the current folder on this disk
            if [ -d "$CURRENT_FOLDER_PATH" ]; then
                CURRENT_FILE_COUNT=$(find "$CURRENT_FOLDER_PATH" -type f 2>/dev/null | wc -l)
            else
                CURRENT_FILE_COUNT=0
            fi
            
            # --- 4. Decision Logic (Prioritization) ---
            
            # If no disk has been chosen yet, choose this one.
            if [ -z "$BEST_DEST_DISK" ]; then
                BEST_DEST_DISK="$disk_name"
                MAX_FILE_COUNT="$CURRENT_FILE_COUNT"
                MAX_FREE_SPACE="$CURRENT_FREE_SPACE"
                continue
            fi
            
            # Primary Check: Does this candidate have MORE files than the current BEST?
            if [ "$CURRENT_FILE_COUNT" -gt "$MAX_FILE_COUNT" ]; then
                BEST_DEST_DISK="$disk_name"
                MAX_FILE_COUNT="$CURRENT_FILE_COUNT"
                MAX_FREE_SPACE="$CURRENT_FREE_SPACE"
                continue
            fi
            
            # Secondary Check (Tie-breaker): If file counts are equal, does this candidate have MORE free space?
            if [ "$CURRENT_FILE_COUNT" -eq "$MAX_FILE_COUNT" ] && [ "$CURRENT_FREE_SPACE" -gt "$MAX_FREE_SPACE" ]; then
                BEST_DEST_DISK="$disk_name"
                MAX_FILE_COUNT="$CURRENT_FILE_COUNT"
                MAX_FREE_SPACE="$CURRENT_FREE_SPACE"
            fi
        done # End disk loop
        
        # 2b. Finalize move for this folder
        if [ -n "$BEST_DEST_DISK" ]; then
            # Record the move in the plan
            PLAN_ARRAY+=("$share_component|$BEST_DEST_DISK")
            
            # Print plan item
            echo "  [PLAN]: Consolidate '${share_component}' -> $BEST_DEST_DISK (Priority: Files=$MAX_FILE_COUNT, Free=$(numfmt --to=iec --from-unit=1K $MAX_FREE_SPACE)) (Size: $(numfmt --to=iec --from-unit=1K $folder_size))"

        else
            echo "  [SKIP]: '${share_component}' (Size: $(numfmt --to=iec --from-unit=1K $folder_size)) - No disk meets the $(numfmt --to=iec --from-unit=1K $MIN_FREE_SPACE_KB) safety margin requirement."
        fi

    done < <(find "$BASE_SHARE" -mindepth 1 -maxdepth 1 -type d) # Find all subdirectories

    # 3. Execute the Plan (Unchanged logic from here)
    echo ""
    echo "--------------------------------------------------------"
    if [ "${#PLAN_ARRAY[@]}" -eq 0 ]; then
        echo "The plan is empty. No moves required or possible."
        return 0
    fi
    
    if [ "$dry_run" = true ]; then
        echo "PLAN COMPLETE. Rerun with -f to execute moves."
        return 0
    fi
    
    echo "Executing Plan..."
    
    for plan_item in "${PLAN_ARRAY[@]}"; do
        SRCDIR="${plan_item%|*}"        
        DESTDISK="${plan_item#*|}"      
        
        echo ">> Executing: $SRCDIR -> $DESTDISK"
        
        # Ensure the destination directory exists
        mkdir -p "/mnt/$DESTDISK/$SRCDIR"

        # Loop through all possible source disks (including cache)
        for d in /mnt/{disk[1-9]{,[0-9]},cache}; do
            # Check if source directory exists AND it's not the destination disk
            if [ -d "$d/$SRCDIR" -a "/mnt/$DESTDISK" != "$d" ]; then
                [ $verbose -gt 0 ] && echo "  Merging data from $d..."

                # Use rsync to move contents (The safe move)
                rsync -avh --remove-source-files "$d/$SRCDIR/" "/mnt/$DESTDISK/$SRCDIR/"
                
                # Check rsync status
                if [ $? -eq 0 ]; then
                    # SAFELY remove directories only if they are empty
                    find "$d/$SRCDIR" -type d -empty -delete
                    
                    # Attempt to remove the share root on that disk if it's now empty
                    rmdir "$d/$SRCDIR" 2>/dev/null || true
                else
                    echo "  WARNING: Rsync failed on $d/$SRCDIR. Skipping cleanup." >&2
                fi
            fi
        done
        echo "Move complete for $SRCDIR."
    done

    echo "ALL MOVES COMPLETE."
}

# --- Main Execution Flow ---

if [ "$auto_mode" = true ]; then
    auto_plan_and_execute
else
    # --- INTERACTIVE MODE (Placeholder) ---
    echo "------------------------------------------------"
    echo "  UnRAID Consolidation Script (Interactive)     "
    echo "------------------------------------------------"
    echo "Interactive mode not fully implemented in this version. Run with -a for auto mode."
    exit 1
fi
